var THREE = require.call(null, 'three');
var lsysParams = require.call(null, 'vpf_experiments/lsystem/params.js');
var lsysUtils = require.call(null, 'vpf_experiments/lsystem/utils.js');
var bounds = require.call(null, 'src/bounds');
var utils = require.call(null, 'vpf_experiments/utils.js');

var vec2 = function(x, y) {
	var v = Object.create(THREE.Vector2.prototype);
	THREE.Vector2.call(v, x, y);
	return v;
}

var box2 = function() {
	var b = Object.create(THREE.Box2.prototype);
	THREE.Box2.call(b);
	return b;
}

var polar2rect = function(r, theta) {
	return vec2(r*Math.cos(theta), r*Math.sin(theta));
}


var viewport = {xmin: -12, xmax: 12, ymin: -22, ymax: 2};

// var targetName = 'curl';
// var targetName = 'bifurcate';
var targetName = 'a';

var targetImg = lsysUtils.newImageData2D().loadFromFile('vpf_experiments/lsystem/targets/' + targetName + '_50.png')
var canvas = lsysUtils.newCanvas(50, 50);
var computeSim = function(branches, inInference) {
	// If not in inference, just render everything
	if (!inInference) {
		lsysUtils.render(canvas, viewport, branches);
	// Otherwise, do an incremental render from the last group of
	//    branches we saw.
	} else {
		if (globalStore.genImg) {
			globalStore.genImg.copyToCanvas(canvas);
		}
		var starti = globalStore.prevBranches ? globalStore.prevBranches.length : 0;
		lsysUtils.render(canvas, viewport, branches, starti, branches.length, starti === 0);
		globalStore.prevBranches = branches;
	}
	globalStore.genImg = lsysUtils.newImageData2D();
	globalStore.genImg.loadFromCanvas(canvas);
	var genImg = globalStore.genImg;

	return genImg.percentSameBinary(targetImg);

	// var accuracy = genImg.percentFilledSameBinary(targetImg);
	// var coverage = targetImg.percentFilledSameBinary(genImg);
	// // return accuracy * coverage;
	// return 0.25*accuracy + 0.75*coverage;
	// // return Math.min(accuracy, coverage);
	// // return accuracy;
	// return coverage;
};
var makescore = function(val, target, tightness) {
	var diff = val - target;
	return - (diff * diff) / (tightness * tightness);
}
var tightness = 0.01;
var targetFactor = function() {
	var sim = computeSim(globalStore.branches, true);
	/////
	globalStore.sim = sim;
	/////
	var f = makescore(sim, 1, tightness);
	if (globalStore.prevFactor) {
		factor(f - globalStore.prevFactor);
	} else {
		factor(f);
	}
	globalStore.prevFactor = f;
};


var vparams = Variational.newParams();



var makeProgram = function(variational, heuristicFactors) {

	// var _gaussian = gaussian;
	var _gaussian = !variational ? gaussian :
	function(mu, sigma) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.none, bounds.nonNegative];
		var features = globalStore.currFeatures;
		var origprms = [mu, sigma];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.gaussianERP.importanceERP.setParams(params);
		return sample(Variational.gaussianERP, origprms);
	};

	// var _uniform = uniform;
	var _uniform = !variational ? uniform :
	function(lo, hi) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.nonNegative, bounds.nonNegative];
		var features = globalStore.currFeatures;
		var origprms = [1, 1];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.betaERP.importanceERP.setParams(params);
		var t = sample(Variational.betaERP, origprms);
		return (1-t)*lo + t*hi;
	};

	// var _flip = flip;
	var _flip = !variational ? flip :
	function(p) {
		var addr = currentAddress();
		var callsite = addr.slice(addr.lastIndexOf('_'));
		var bnds = [bounds.unitInterval];
		var features = globalStore.currFeatures;
		var origprms = [p];
		var params = lsysParams.get(vparams, callsite, origprms, bnds, features);
		Variational.bernoulliERP.importanceERP.setParams(params);
		return sample(Variational.bernoulliERP, origprms);
	};


	var fuzz = [0, 1e-8];
	var normalize = function(x, lo, hi) {
		// Fuzz prevents values from normalizing to zero and causing zero derivatives.
		// Also might make learning a bit more robust(?)
		return (2 * (x - lo) / (hi - lo)) - 1 + gaussianERP.sample(fuzz);
		// return (x - lo) / (hi - lo) + gaussianERP.sample(fuzz);
	};
	var TWOPI = 2*Math.PI;
	var normang = function(theta) {
		if (theta >= 0) {
			return theta - (TWOPI*Math.floor(theta / TWOPI));
		} else {
			return theta - (TWOPI*Math.ceil(theta / TWOPI)) + TWOPI;
		}
	};
	var setCurrFeatures = function(currState) {
		var x = normalize(currState.pos.x, viewport.xmin, viewport.xmax);
		var y = normalize(currState.pos.y, viewport.ymin, viewport.ymax);
		var depth = normalize(currState.depth, 0, 5);
		var ang = normalize(normang(currState.angle), 0, TWOPI);
		globalStore.currFeatures = [x, y, depth, ang];
	};

	var branch = function(currState) {
		setCurrFeatures(currState);

		var width = 0.9 * currState.width;
		var length = 2;
		var newang = currState.angle + _gaussian(0, Math.PI/8);	
		// var newang = currState.angle + _uniform(-Math.PI/6, Math.PI/6);
		var newbranch = {
			start: currState.pos,
			angle: newang,
			width: width,
			end: currState.pos.clone().add(polar2rect(length, newang))
		};

		globalStore.branches = globalStore.branches.concat([newbranch]);

		if (heuristicFactors) {
			// Add new heuristic factor
			targetFactor();
		}

		var newState = {
			depth: currState.depth + 1,
			pos: newbranch.end,
			angle: newbranch.angle,
			width: newbranch.width
		};

		// Terminate?
		future(function() {
			// if (currState.depth < 10 && _flip(Math.min(0.99, Math.exp(-0.5*(currState.depth-4))))) {
			if (currState.depth < 15 && _flip(0.5)) {
				future(function() {
					// Continue or fork?
					if (_flip(0.5)) {
						branch(newState);
					} else {
						var branchState1 = {
							depth: currState.depth + 1,
							pos: newbranch.end,
							angle: newbranch.angle - Math.abs(_gaussian(0, Math.PI/6)),
							// angle: newbranch.angle - _uniform(0, Math.PI/4),
							width: newbranch.width
						};
						branch(branchState1);
						var branchState2 = {
							depth: currState.depth + 1,
							pos: newbranch.end,
							angle: newbranch.angle + Math.abs(_gaussian(0, Math.PI/6)),
							// angle: newbranch.angle + _uniform(0, Math.PI/4),
							width: newbranch.width
						};
						branch(branchState2);
					}
				});
			}
		});
	};

	var generate = function() {
		globalStore.branches = [];
		globalStore.currFeatures = [];
		var startState = {
			depth: 0,
			pos: vec2(0, 0),
			angle: -Math.PI/2,
			width: 0.75
		};
		future(function() { branch(startState); });
		finishAllFutures();

		if (!heuristicFactors) {
			// Target factor only once, at very end
			targetFactor();
		}

		return globalStore.branches;
	};

	return generate;
}

var variational = false;
var heuristicFactors = true;
// var futurePolicy = 'deterministic';
var futurePolicy = 'stochastic';
setFuturePolicy(futurePolicy);
var generate = makeProgram(variational, heuristicFactors);


if (variational) {
	Variational(generate, vparams, {
		numParticles: 100,
		maxNumFlights: 300,
		// convergeEps: 0.1,
		convergeEps: 0.01,
		adagradInitLearnRate: 0.25,
		// adagradInitLearnRate: 0.1,
		// adagradInitLearnRate: 0.05,

		gradientEstimator: 'ELBO',
		// gradientEstimator: 'VPF',

		verbosity: {
			flightNum: true,
			scoreDiff: true,
			endStatus: true
		}
	});
	// console.log(vparams);
}

var testRun = function() {
	var res = {width: 600, height: 600};
	var n = 10;
	var skip = 1;
	var name = 'test';
	var resultsDir = 'vpf_experiments/lsystem/results/image/' + name;
	var fs = require.call(null, 'fs');
	if (!fs.existsSync(resultsDir)) {
		fs.mkdirSync(resultsDir);
	}
	var sims = repeat(n, function(i) {
		// var nParticles = 1;
		// var nParticles = 100;
		var nParticles = 300;
		var ret = sample(ParticleFilter(generate, nParticles));
		// var ret = sample(MH(generate, 1000));
		var sim = computeSim(ret);
		console.log(i + ' | sim: ' + sim);
		if (i % skip === 0) {
			lsysUtils.renderOut(resultsDir + '/' + (i/skip) + '.png', res, viewport, ret);
		}
		return sim;
	});
	console.log('sim -  min: ' + listMin(sims) + ', max: ' + listMax(sims) +
		               ', avg: ' + listMean(sims) + ', stddev: ' + listStdev(sims));
}
// testRun();


var serverReponse = function() {
	var nParticles = 300;
	// var nParticles = 100;
	var dist = ParticleFilter(generate, nParticles, true, true);
	var history = map(function(particles) {
		return map(function(particle) {
			return {
				log_prior: particle.logprior,
				log_like: particle.loglike,
				log_post: particle.logpost,
				active: particle.active,
				similarity: particle.store.sim,
				branches: particle.store.branches
			};
		}, particles);
	}, dist.particleHistory);
	return {
		targetName: targetName,
		viewport: viewport,
		history: history
	};
}
serverReponse();





